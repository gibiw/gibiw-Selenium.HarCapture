---
phase: 02-capture-infrastructure
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - src/Selenium.HarCapture/Capture/HarCaptureSession.cs
  - tests/Selenium.HarCapture.Tests/Capture/CaptureTypeTests.cs
  - tests/Selenium.HarCapture.Tests/Capture/CaptureOptionsTests.cs
  - tests/Selenium.HarCapture.Tests/Capture/Internal/UrlPatternMatcherTests.cs
  - tests/Selenium.HarCapture.Tests/Capture/Internal/RequestResponseCorrelatorTests.cs
  - tests/Selenium.HarCapture.Tests/Capture/HarCaptureSessionTests.cs
autonomous: true
requirements:
  - CAP-01
  - CAP-05
  - CAP-06

must_haves:
  truths:
    - "User can start and stop capture via HarCaptureSession with explicit Start/Stop lifecycle methods"
    - "User can create multi-page captures with NewPage(pageRef, pageTitle) that organize entries into HAR pages"
    - "User can call GetHar() to get a deep-cloned snapshot while capture continues"
    - "GetHar() deep clone is independent — modifying the clone does not affect live capture"
    - "HarCaptureSession implements IDisposable and cleans up strategy on dispose"
    - "Thread-safe correlation produces correct HarEntry from concurrent request+response events"
    - "URL pattern matcher correctly filters with include/exclude glob patterns"
  artifacts:
    - path: "src/Selenium.HarCapture/Capture/HarCaptureSession.cs"
      provides: "Public orchestrator with Start/Stop/NewPage/GetHar"
      contains: "public sealed class HarCaptureSession"
    - path: "tests/Selenium.HarCapture.Tests/Capture/HarCaptureSessionTests.cs"
      provides: "Unit tests for orchestrator lifecycle, NewPage, GetHar deep clone"
      contains: "[Fact]"
    - path: "tests/Selenium.HarCapture.Tests/Capture/Internal/RequestResponseCorrelatorTests.cs"
      provides: "Unit tests for thread-safe correlation"
      contains: "[Fact]"
    - path: "tests/Selenium.HarCapture.Tests/Capture/Internal/UrlPatternMatcherTests.cs"
      provides: "Unit tests for URL pattern matching"
      contains: "[Fact]"
    - path: "tests/Selenium.HarCapture.Tests/Capture/CaptureTypeTests.cs"
      provides: "Unit tests for flags enum bitwise operations"
      contains: "[Fact]"
    - path: "tests/Selenium.HarCapture.Tests/Capture/CaptureOptionsTests.cs"
      provides: "Unit tests for default values"
      contains: "[Fact]"
  key_links:
    - from: "src/Selenium.HarCapture/Capture/HarCaptureSession.cs"
      to: "src/Selenium.HarCapture/Capture/Strategies/INetworkCaptureStrategy.cs"
      via: "holds _strategy field, subscribes to EntryCompleted"
      pattern: "_strategy"
    - from: "src/Selenium.HarCapture/Capture/HarCaptureSession.cs"
      to: "src/Selenium.HarCapture/Serialization/HarSerializer.cs"
      via: "JSON round-trip for deep cloning in GetHar()"
      pattern: "HarSerializer\\.Serialize.*HarSerializer\\.Deserialize"
    - from: "src/Selenium.HarCapture/Capture/HarCaptureSession.cs"
      to: "src/Selenium.HarCapture/Capture/Internal/UrlPatternMatcher.cs"
      via: "URL filtering before adding entries"
      pattern: "UrlPatternMatcher"
    - from: "src/Selenium.HarCapture/Capture/HarCaptureSession.cs"
      to: "src/Selenium.HarCapture/Capture/CaptureOptions.cs"
      via: "constructor parameter for configuration"
      pattern: "CaptureOptions"
---

<objective>
Create the HarCaptureSession public orchestrator and comprehensive unit tests for all Phase 2 components.

Purpose: HarCaptureSession is the main public class users interact with to start/stop capture, manage pages, and retrieve HAR snapshots. Tests validate all infrastructure components (CaptureType, CaptureOptions, UrlPatternMatcher, RequestResponseCorrelator, HarCaptureSession) without needing actual WebDriver — using a mock strategy for orchestrator tests.

Output: 1 new source file (HarCaptureSession) and 5 new test files covering all Phase 2 functionality.
</objective>

<execution_context>
@/Users/gda/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-capture-infrastructure/02-RESEARCH.md
@.planning/phases/02-capture-infrastructure/02-01-SUMMARY.md
@src/Selenium.HarCapture/Capture/CaptureType.cs
@src/Selenium.HarCapture/Capture/CaptureOptions.cs
@src/Selenium.HarCapture/Capture/Strategies/INetworkCaptureStrategy.cs
@src/Selenium.HarCapture/Capture/Internal/RequestResponseCorrelator.cs
@src/Selenium.HarCapture/Capture/Internal/UrlPatternMatcher.cs
@src/Selenium.HarCapture/Serialization/HarSerializer.cs
@src/Selenium.HarCapture/Models/Har.cs
@src/Selenium.HarCapture/Models/HarLog.cs
@src/Selenium.HarCapture/Models/HarEntry.cs
@src/Selenium.HarCapture/Models/HarPage.cs
@src/Selenium.HarCapture/Models/HarCreator.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: HarCaptureSession orchestrator class</name>
  <files>
    src/Selenium.HarCapture/Capture/HarCaptureSession.cs
  </files>
  <action>
Create `HarCaptureSession.cs` in `Selenium.HarCapture.Capture` namespace.

**Class naming:** Use `HarCaptureSession` (not `HarCapture`) to avoid collision with the root namespace `Selenium.HarCapture`. The name also better describes what it is — a capture session.

**Class declaration:** `public sealed class HarCaptureSession : IDisposable`

**Constructor overloads:**
1. `public HarCaptureSession(CaptureOptions? options = null)` — creates session without a strategy (for testing, or when strategy will be set via internal method)
2. `internal HarCaptureSession(INetworkCaptureStrategy strategy, CaptureOptions? options = null)` — accepts strategy directly (used by future factory methods and by unit tests via InternalsVisibleTo)

Both constructors: store options (default to `new CaptureOptions()` if null), create `UrlPatternMatcher` from options patterns, initialize state.

**Private fields:**
- `private readonly CaptureOptions _options`
- `private readonly UrlPatternMatcher _urlMatcher`
- `private readonly object _lock = new object()`
- `private INetworkCaptureStrategy? _strategy`
- `private Har _har = null!`
- `private string? _currentPageRef`
- `private bool _isCapturing`
- `private bool _disposed`

**Public properties:**
- `public bool IsCapturing => _isCapturing`
- `public string? ActiveStrategyName => _strategy?.StrategyName`

**StartAsync / Start:**
- `public async Task StartAsync(string? initialPageRef = null, string? initialPageTitle = null)`
  - Throws `ObjectDisposedException` if disposed
  - Throws `InvalidOperationException("Capture is already started.")` if `_isCapturing`
  - If `_strategy` is null, throw `InvalidOperationException("No capture strategy configured. Strategy creation will be available in Phase 3/4.")` — this is the placeholder for future strategy creation logic
  - Subscribe to `_strategy.EntryCompleted += OnEntryCompleted`
  - Call `InitializeHar(initialPageRef, initialPageTitle)`
  - Call `await _strategy.StartAsync(_options).ConfigureAwait(false)`
  - Set `_isCapturing = true`
- `public void Start(string? initialPageRef = null, string? initialPageTitle = null)` — calls `StartAsync(...).GetAwaiter().GetResult()`

**StopAsync / Stop:**
- `public async Task&lt;Har&gt; StopAsync()`
  - Throws `ObjectDisposedException` if disposed
  - Throws `InvalidOperationException("Capture is not started.")` if not `_isCapturing`
  - Call `await _strategy!.StopAsync().ConfigureAwait(false)`
  - Set `_isCapturing = false`
  - Unsubscribe `_strategy.EntryCompleted -= OnEntryCompleted`
  - Return `_har` (no clone needed, capture stopped)
- `public Har Stop()` — calls `StopAsync().GetAwaiter().GetResult()`

**NewPage:**
- `public void NewPage(string pageRef, string pageTitle)`
  - Throws `ObjectDisposedException` if disposed
  - Throws `InvalidOperationException("Capture is not started.")` if not `_isCapturing`
  - Throws `ArgumentNullException` if pageRef or pageTitle is null
  - Lock on `_lock`:
    - Create `new HarPage { Id = pageRef, Title = pageTitle, StartedDateTime = DateTimeOffset.UtcNow, PageTimings = new HarPageTimings() }`
    - Build new pages list from existing: `var pages = new List&lt;HarPage&gt;(_har.Log.Pages ?? (IEnumerable&lt;HarPage&gt;)Array.Empty&lt;HarPage&gt;()) { page }`
    - Build new entries list (keep existing): `var entries = new List&lt;HarEntry&gt;(_har.Log.Entries ?? (IEnumerable&lt;HarEntry&gt;)Array.Empty&lt;HarEntry&gt;())`
    - Recreate Har: `_har = new Har { Log = new HarLog { Version = _har.Log.Version, Creator = _har.Log.Creator, Browser = _har.Log.Browser, Pages = pages, Entries = entries, Comment = _har.Log.Comment } }`
    - Set `_currentPageRef = pageRef`

CRITICAL: HAR models are sealed classes with `init` properties, NOT records. The `with` expression does NOT work. Always create new instances using object initializer syntax. When rebuilding Har/HarLog, copy ALL existing properties to the new instance.

**GetHar:**
- `public Har GetHar()`
  - Throws `ObjectDisposedException` if disposed
  - Throws `InvalidOperationException("Capture is not started.")` if not `_isCapturing`
  - Lock on `_lock`:
    - Deep clone via JSON round-trip: `var json = HarSerializer.Serialize(_har, writeIndented: false);`
    - `return HarSerializer.Deserialize(json);`

**Private methods:**

`private void InitializeHar(string? initialPageRef, string? initialPageTitle)`:
- Lock on `_lock`:
  - Create initial pages list (empty or with initial page if pageRef provided)
  - `_har = new Har { Log = new HarLog { Version = "1.2", Creator = new HarCreator { Name = _options.CreatorName, Version = typeof(HarCaptureSession).Assembly.GetName().Version?.ToString() ?? "1.0.0" }, Pages = pages, Entries = new List&lt;HarEntry&gt;() } }`
  - Set `_currentPageRef = initialPageRef`

`private void OnEntryCompleted(HarEntry entry, string requestId)`:
- Check `_urlMatcher.ShouldCapture(entry.Request.Url)` — if false, return
- Lock on `_lock`:
  - If `_currentPageRef != null`, create new entry with PageRef set: `entry = new HarEntry { StartedDateTime = entry.StartedDateTime, Time = entry.Time, Request = entry.Request, Response = entry.Response, Cache = entry.Cache, Timings = entry.Timings, PageRef = _currentPageRef, ServerIPAddress = entry.ServerIPAddress, Connection = entry.Connection, Comment = entry.Comment }`
  - Build new entries list: `var entries = new List&lt;HarEntry&gt;(_har.Log.Entries ?? (IEnumerable&lt;HarEntry&gt;)Array.Empty&lt;HarEntry&gt;()) { entry }`
  - Rebuild Har with new entries list (same pattern as NewPage — copy all HarLog properties, replace Entries)

**Dispose:**
- `public void Dispose()`:
  - If `_disposed`, return
  - If `_strategy != null`: unsubscribe `EntryCompleted`, call `_strategy.Dispose()`, set null
  - Set `_disposed = true`

**Add InternalsVisibleTo** in csproj or via AssemblyInfo: Add `[assembly: InternalsVisibleTo("Selenium.HarCapture.Tests")]` to make internal types (INetworkCaptureStrategy, RequestResponseCorrelator, UrlPatternMatcher) visible to tests. Add this as an `<InternalsVisibleTo>` item in the csproj file:
```xml
<ItemGroup>
  <InternalsVisibleTo Include="Selenium.HarCapture.Tests" />
</ItemGroup>
```

XML doc comments on class and all public members.
  </action>
  <verify>
Run `dotnet build src/Selenium.HarCapture` — must compile with 0 errors, 0 warnings. Verify class is public sealed, implements IDisposable. Verify InternalsVisibleTo is in csproj.
  </verify>
  <done>
HarCaptureSession is a public sealed class with Start/Stop/NewPage/GetHar lifecycle, IDisposable cleanup, URL filtering via UrlPatternMatcher, deep clone via HarSerializer, lock-based thread safety, and internal constructor for testability. InternalsVisibleTo enables test access to internal types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Comprehensive unit tests for all Phase 2 components</name>
  <files>
    tests/Selenium.HarCapture.Tests/Capture/CaptureTypeTests.cs
    tests/Selenium.HarCapture.Tests/Capture/CaptureOptionsTests.cs
    tests/Selenium.HarCapture.Tests/Capture/Internal/UrlPatternMatcherTests.cs
    tests/Selenium.HarCapture.Tests/Capture/Internal/RequestResponseCorrelatorTests.cs
    tests/Selenium.HarCapture.Tests/Capture/HarCaptureSessionTests.cs
  </files>
  <action>
Create 5 test files. All use xUnit [Fact]/[Theory], FluentAssertions, same patterns as existing tests. All in `Selenium.HarCapture.Tests.Capture` or sub-namespaces.

**CaptureTypeTests.cs** (namespace: `Selenium.HarCapture.Tests.Capture`):
- `None_HasValue_Zero`: Assert `(int)CaptureType.None == 0`
- `IndividualFlags_ArePowersOfTwo`: Assert each of the 10 individual flags is a distinct power of 2
- `HasFlag_Works_ForCombinations`: Assert `CaptureType.AllText.HasFlag(CaptureType.RequestHeaders)` is true, `CaptureType.AllText.HasFlag(CaptureType.RequestBinaryContent)` is false
- `HeadersAndCookies_IncludesCorrectFlags`: Assert includes RequestHeaders, RequestCookies, ResponseHeaders, ResponseCookies and does NOT include RequestContent, ResponseContent, Timings
- `All_IncludesEverything`: Assert All includes every individual flag
- `BitwiseOr_CombinesFlags`: Assert `(CaptureType.RequestHeaders | CaptureType.Timings).HasFlag(CaptureType.RequestHeaders)` and `.HasFlag(CaptureType.Timings)` are true

**CaptureOptionsTests.cs** (namespace: `Selenium.HarCapture.Tests.Capture`):
- `Defaults_AreCorrect`: New CaptureOptions() has CaptureTypes=AllText, CreatorName="Selenium.HarCapture", ForceSeleniumNetworkApi=false, MaxResponseBodySize=0, UrlIncludePatterns=null, UrlExcludePatterns=null
- `Properties_CanBeSet`: Set all properties and verify values

**UrlPatternMatcherTests.cs** (namespace: `Selenium.HarCapture.Tests.Capture.Internal`):
- `NoPatterns_CapturesAll`: `new UrlPatternMatcher(null, null).ShouldCapture("https://example.com")` is true
- `IncludePattern_MatchesUrl`: Include `["https://api.example.com/**"]`, URL `https://api.example.com/users` returns true
- `IncludePattern_RejectsNonMatchingUrl`: Include `["https://api.example.com/**"]`, URL `https://other.com/data` returns false
- `ExcludePattern_RejectsMatchingUrl`: Exclude `["**/*.png"]`, URL `https://example.com/logo.png` returns false
- `ExcludePattern_AllowsNonMatchingUrl`: Exclude `["**/*.png"]`, URL `https://example.com/data.json` returns true
- `ExcludeTakesPrecedence_OverInclude`: Include `["https://example.com/**"]`, Exclude `["**/*.png"]`, URL `https://example.com/image.png` returns false
- `MultipleIncludePatterns_AnyMatch`: Include `["https://api.example.com/**", "https://cdn.example.com/**"]`, both matching URLs return true
- `CaptureAll_CapturesEverything`: `UrlPatternMatcher.CaptureAll.ShouldCapture(...)` returns true for any URL

**RequestResponseCorrelatorTests.cs** (namespace: `Selenium.HarCapture.Tests.Capture.Internal`):
- `OnRequestSent_ThenResponseReceived_ReturnsEntry`: Send request for "req1", then receive response for "req1" — returns non-null HarEntry with correct Request, Response, StartedDateTime, Time
- `OnResponseReceived_WithoutRequest_ReturnsNull`: Receive response for unknown "req99" — returns null
- `OnRequestSent_DoesNotReturnEntry`: Just sending a request does not produce an entry (method is void)
- `PendingCount_TracksUnmatchedRequests`: Send 3 requests — PendingCount is 3. Receive 1 response — PendingCount is 2.
- `Clear_RemovesAllPending`: Send requests, call Clear(), PendingCount is 0
- `ConcurrentAccess_DoesNotThrow`: Use `Parallel.For` to send 100 requests and 100 responses concurrently — no exceptions thrown, all entries produced (use Thread.Sleep(0) or Task.Yield to introduce interleaving)

Helper method `CreateTestRequest(string url = "https://example.com")`: returns `new HarRequest { Method = "GET", Url = url, HttpVersion = "HTTP/1.1", Cookies = new List&lt;HarCookie&gt;(), Headers = new List&lt;HarHeader&gt;(), QueryString = new List&lt;HarQueryString&gt;(), HeadersSize = -1, BodySize = -1 }`

Helper method `CreateTestResponse()`: returns `new HarResponse { Status = 200, StatusText = "OK", HttpVersion = "HTTP/1.1", Cookies = new List&lt;HarCookie&gt;(), Headers = new List&lt;HarHeader&gt;(), Content = new HarContent { Size = 0, MimeType = "text/html" }, RedirectURL = "", HeadersSize = -1, BodySize = -1 }`

**HarCaptureSessionTests.cs** (namespace: `Selenium.HarCapture.Tests.Capture`):

First create a `MockCaptureStrategy` private class inside the test class (or as internal class in the test file):
```
private sealed class MockCaptureStrategy : INetworkCaptureStrategy
{
    public string StrategyName => "Mock";
    public bool SupportsDetailedTimings => true;
    public bool SupportsResponseBody => true;
    public event Action<HarEntry, string>? EntryCompleted;
    private bool _started;

    public Task StartAsync(CaptureOptions options) { _started = true; return Task.CompletedTask; }
    public Task StopAsync() { _started = false; return Task.CompletedTask; }
    public void Dispose() { }

    // Test helper to simulate an entry arriving
    public void SimulateEntry(HarEntry entry, string requestId)
        => EntryCompleted?.Invoke(entry, requestId);
}
```

Tests:
- `Start_InitializesHar_WithVersion12`: Start, GetHar(), verify Log.Version is "1.2"
- `Start_InitializesHar_WithCreatorName`: Start with custom CreatorName in options, verify it in GetHar()
- `Start_WithInitialPage_CreatesPage`: Start("page1", "Home"), GetHar() has 1 page with correct Id and Title
- `Start_WithoutInitialPage_HasEmptyPages`: Start(null, null), GetHar() has empty pages list
- `Start_WhenAlreadyStarted_ThrowsInvalidOperation`: Start, then Start again throws
- `Stop_ReturnsHar`: Start, Stop returns non-null Har
- `Stop_WhenNotStarted_ThrowsInvalidOperation`: Stop without Start throws
- `NewPage_AddsPageToHar`: Start, NewPage("p2", "About"), GetHar() has page with id="p2"
- `NewPage_WhenNotCapturing_ThrowsInvalidOperation`: NewPage without Start throws
- `NewPage_SetsCurrentPageRef_OnNewEntries`: Start("p1","Home"), simulate entry, verify pageRef="p1". NewPage("p2","About"), simulate another entry, verify pageRef="p2"
- `GetHar_ReturnsDeepClone`: Start, simulate entry, GetHar() twice — modify first clone's entries list, second clone is unaffected
- `GetHar_WhenNotCapturing_ThrowsInvalidOperation`: GetHar without Start throws
- `EntryCompleted_AddsEntryToHar`: Start, simulate entry via mock, GetHar() has 1 entry
- `EntryCompleted_FiltersExcludedUrls`: Create session with UrlExcludePatterns=["**/*.png"], simulate entry with .png URL, GetHar() has 0 entries. Simulate entry with .html URL, GetHar() has 1 entry.
- `Dispose_CleansUpStrategy`: Create session, Start, Dispose — simulate entry, GetHar should not add it (strategy disposed)
- `Dispose_WhenCalledTwice_DoesNotThrow`: Dispose twice, no exception
- `ActiveStrategyName_ReturnsStrategyName`: Verify returns "Mock" after construction

For creating test entries, use helper:
```
private static HarEntry CreateTestEntry(string url = "https://example.com/page")
{
    return new HarEntry
    {
        StartedDateTime = DateTimeOffset.UtcNow,
        Time = 100,
        Request = new HarRequest { Method = "GET", Url = url, HttpVersion = "HTTP/1.1", Cookies = new List<HarCookie>(), Headers = new List<HarHeader>(), QueryString = new List<HarQueryString>(), HeadersSize = -1, BodySize = -1 },
        Response = new HarResponse { Status = 200, StatusText = "OK", HttpVersion = "HTTP/1.1", Cookies = new List<HarCookie>(), Headers = new List<HarHeader>(), Content = new HarContent { Size = 0, MimeType = "text/html" }, RedirectURL = "", HeadersSize = -1, BodySize = -1 },
        Cache = new HarCache(),
        Timings = new HarTimings { Send = 1, Wait = 50, Receive = 49 }
    };
}
```
  </action>
  <verify>
Run `dotnet test` — ALL tests must pass (26 existing + new tests). Expect approximately 40-50 total tests. 0 failures. Run `dotnet build` for the whole solution — 0 errors, 0 warnings.
  </verify>
  <done>
5 test files created covering CaptureType (6 tests), CaptureOptions (2 tests), UrlPatternMatcher (8 tests), RequestResponseCorrelator (6 tests), HarCaptureSession (17 tests). All tests pass including original 26. Total test count approximately 65. Full Phase 2 infrastructure validated.
  </done>
</task>

</tasks>

<verification>
- `dotnet build` on full solution: 0 errors, 0 warnings
- `dotnet test` passes all tests (approximately 65 total — 26 existing + ~39 new)
- HarCaptureSession lifecycle works: Start -> capture entries -> NewPage -> GetHar (deep clone) -> Stop
- URL filtering correctly excludes/includes based on glob patterns
- RequestResponseCorrelator handles concurrent access without exceptions
- CaptureType flags combine correctly with bitwise operations
- GetHar() produces independent deep clones (modifying one does not affect another)
- Dispose cleans up strategy and prevents further use
</verification>

<success_criteria>
6 new files created. All tests pass. HarCaptureSession provides complete capture lifecycle (Start/Stop/NewPage/GetHar) with IDisposable cleanup, URL filtering, deep-clone snapshots, and lock-based thread safety. Phase 2 infrastructure is ready for CDP strategy implementation in Phase 3.
</success_criteria>

<output>
After completion, create `.planning/phases/02-capture-infrastructure/02-02-SUMMARY.md`
</output>
